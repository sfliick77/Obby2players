<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mini Obby 3D ‚Äî 2 Jogadores</title>
  <style>
    :root { --ui: rgba(0,0,0,.8); --txt: #fff; }
    * { box-sizing: border-box; }
    body { margin: 0; overflow: hidden; background:#000; font-family: Arial, Helvetica, sans-serif; }
    canvas { display: block; }

    /* Overlay inicial */
    #overlay {
      position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center;
      gap: 18px; text-align: center; color: var(--txt); background: rgba(0,0,0,.85); z-index: 20; padding: 24px;
    }
    #overlay h1 { margin: 0; font-size: 28px; }
    #overlay p { margin: 0; opacity: .9; }
    .btn { cursor: pointer; padding: 10px 18px; border-radius: 8px; border: 1px solid #fff; background: var(--ui); color: #fff; font-size: 16px; }
    .btn:hover { background: rgba(255,255,255,.12); }

    /* HUD */
    #info {
      position: absolute; top: 10px; left: 10px; color: #fff; font-size: 16px; text-shadow: 0 1px 3px #000; display: none; z-index: 15;
      background: rgba(0,0,0,.35); padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,.2);
    }

    /* Menu */
    #menu-btn { position: absolute; top: 15px; right: 15px; background: rgba(0,0,0,.6); color:#fff; border: 1px solid #fff; border-radius: 8px; padding: 8px 14px; cursor:pointer; z-index: 15; }
    #menu-btn:hover { background: rgba(0,0,0,.8); }

    #options-menu { position: absolute; top: 54px; right: 15px; background: rgba(0,0,0,.85); color:#fff; border: 1px solid #fff; border-radius: 10px; padding: 12px; display: none; flex-direction: column; gap: 10px; min-width: 200px; z-index: 15; }
    .menu-option { display:flex; align-items:center; gap:8px; }

    /* Mensagens */
    #center-msg { position: absolute; left: 50%; top: 15%; transform: translateX(-50%); color:#fff; font-size: 18px; text-shadow: 0 1px 3px #000; z-index: 15; display: none; }
  </style>
</head>
<body>
  <!-- Overlay inicial com bot√£o Iniciar -->
  <div id="overlay">
    <h1>üèÉ Mini Obby 3D ‚Äî 2 Jogadores</h1>
    <p>Jogador 1: <b>WASD</b> para mover, <b>Espa√ßo</b> para pular.</p>
    <p>Jogador 2: <b>Setas</b> para mover, <b>Enter</b> para pular.</p>
    <button id="start-btn" class="btn">Iniciar</button>
    <p style="opacity:.8">Dica: tamb√©m funciona apertar <b>Espa√ßo</b> ou <b>Enter</b>.</p>
  </div>

  <div id="info"></div>
  <div id="center-msg"></div>

  <button id="menu-btn">‚ò∞ Menu</button>
  <div id="options-menu">
    <label class="menu-option"><input type="checkbox" id="lite-mode"> Modo Lite</label>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    // ======== Estado do jogo ========
    let gameStarted = false;
    let liteMode = false;

    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('start-btn');
    const info = document.getElementById('info');
    const centerMsg = document.getElementById('center-msg');
    const menuBtn = document.getElementById('menu-btn');
    const optionsMenu = document.getElementById('options-menu');
    const liteModeToggle = document.getElementById('lite-mode');

    // ======== Entrada ========
    const keys = {}; // mapa de teclas
    window.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      keys[k] = true;
      if (!gameStarted && (k === 'enter' || k === ' ')) startGame();
      // impedir scroll
      if([' ', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(k)) e.preventDefault();
    });
    window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
    startBtn.addEventListener('click', startGame);

    // ======== Menu ========
    menuBtn.addEventListener('click', () => {
      optionsMenu.style.display = optionsMenu.style.display === 'flex' ? 'none' : 'flex';
    });
    liteModeToggle.addEventListener('change', () => { liteMode = liteModeToggle.checked; applyLiteMode(); });

    // ======== Three.js b√°sico ========
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const loader = new THREE.TextureLoader();
    loader.load(
      'https://raw.githubusercontent.com/sfliick77/Background-c-u/main/277fba7bc86484d9f6cf37c87ee44de2.jpg',
      (texture) => { scene.background = texture; },
      undefined,
      () => { scene.background = new THREE.Color(0x222222); }
    );

    const dirLight = new THREE.DirectionalLight(0xffffff, 1);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));

    // ======== Util ========
    function applyLiteMode(){
      const wire = !!liteMode;
      players.forEach(p => p.mesh.material.wireframe = wire);
      [...platforms, ...movingPlatforms, ...fallingPlatforms, ...bouncePads, ...disappearPlatforms, ...lavaTiles].forEach(m => {
        m.material.wireframe = wire;
      });
      if (wire) scene.background = new THREE.Color(0x222222);
      else loader.load('https://raw.githubusercontent.com/sfliick77/Background-c-u/main/277fba7bc86484d9f6cf37c87ee44de2.jpg', tex => scene.background = tex);
    }

    function showCenterMsg(text, ms=1200){
      centerMsg.textContent = text; centerMsg.style.display = 'block';
      clearTimeout(showCenterMsg._t);
      showCenterMsg._t = setTimeout(()=> centerMsg.style.display = 'none', ms);
    }

    // ======== Jogadores ========
    const players = [];
    const playerSize = 1.02;

    function createPlayer(color, startX, startZ){
      const geom = new THREE.BoxGeometry(playerSize, playerSize, playerSize);
      const mat = new THREE.MeshStandardMaterial({ color });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.position.set(startX, 1, startZ);
      scene.add(mesh);
      return {
        mesh,
        vel: new THREE.Vector3(),
        canJump: false,
        respawn: new THREE.Vector3(startX, 1, startZ),
        checkpointIdx: 0
      };
    }

    const p1 = createPlayer(0xff5555, 0, 0); // vermelho
    const p2 = createPlayer(0x5590ff, 2, 0); // azul
    players.push(p1, p2);

    // ======== Nivel / Obst√°culos ========
    const platforms = [];             // est√°ticas
    const movingPlatforms = [];       // com movimento senoidal
    const fallingPlatforms = [];      // caem quando pisadas
    const disappearPlatforms = [];    // somem e voltam em ciclos
    const bouncePads = [];            // trampolins
    const lavaTiles = [];             // mata instantaneamente
    const rotators = [];              // vigas girat√≥rias (hazard)
    const checkpoints = [];           // checkpoints

    function mkBox(w, h, d, color){
      const geo = new THREE.BoxGeometry(w, h, d);
      const mat = new THREE.MeshStandardMaterial({ color });
      const m = new THREE.Mesh(geo, mat);
      scene.add(m); return m;
    }

    function createPlatform(x,y,z,w=3,d=3,color=0x4caf50){
      const m = mkBox(w, .5, d, color); m.position.set(x,y,z); platforms.push(m); return m;
    }
    function createMovingPlatform({x,y,z,w=3,d=3,axis='x',amp=2,speed=1,color=0x8bc34a}){
      const m = mkBox(w,.5,d,color); m.position.set(x,y,z);
      movingPlatforms.push({mesh:m, base:new THREE.Vector3(x,y,z), axis, amp, speed});
      return m;
    }
    function createFallingPlatform(x,y,z,w=3,d=3,color=0xffd54f){
      const m = mkBox(w,.5,d,color); m.position.set(x,y,z);
      fallingPlatforms.push({mesh:m, state:'idle', timer:0});
      return m;
    }
    function createDisappearPlatform(x,y,z,w=3,d=3, period=2.2, duty=0.5, color=0x9e9e9e){
      const m = mkBox(w,.5,d,color); m.position.set(x,y,z);
      disappearPlatforms.push({mesh:m, period, duty, t0: performance.now()/1000});
      return m;
    }
    function createBouncePad(x,y,z,w=3,d=3,color=0x2196f3){
      const m = mkBox(w,.3,d,color); m.position.set(x,y,z); bouncePads.push(m); return m;
    }
    function createLava(x,y,z,w=3,d=3,color=0xe53935){
      const m = mkBox(w,.2,d,color); m.position.set(x,y,z); lavaTiles.push(m); return m;
    }
    function createRotator(x,y,z,len=6,th=0.35,speed=1,color=0xff7043){
      const m = mkBox(len, th, th, color); m.position.set(x,y,z);
      m._rotSpeed = speed; rotators.push(m); return m;
    }
    function createCheckpoint(x,y,z){
      // poste + base
      const post = mkBox(0.4, 2.0, 0.4, 0x00e676); post.position.set(x, y+1.0, z);
      const base = mkBox(1.6, 0.25, 1.6, 0x2e7d32); base.position.set(x, y+0.125, z);
      const flag = mkBox(1.0, 0.6, 0.1, 0x00e676); flag.position.set(x+0.7, y+1.6, z);
      const area = mkBox(2.8, 0.1, 2.8, 0x1b5e20); area.position.set(x, y+0.05, z); area.material.transparent=true; area.material.opacity=0.35;
      checkpoints.push({x, y, z, marker:[post, base, flag, area]});
      platforms.push(base); // base √© s√≥lida
    }

    // ----- Constru√ß√£o do n√≠vel (bem mais longo) -----
    (function buildLevel(){
      let x = 0, z = 0, y = 0;
      const step = 4.2; // dist√¢ncia entre blocos

      // bloco inicial
      for (let i=0;i<3;i++) createPlatform(x + i*3, y, z, 3, 3, 0x66bb6a);
      createCheckpoint(x+3, y, z);

      // passarela com gaps e lava
      x += 10;
      for (let i=0;i<8;i++){
        if (i%2===0) createPlatform(x + i*step, y, z, 3, 3, 0x66bb6a);
        else createLava(x + i*step, y-0.15, z, 3, 3, 0xe53935);
      }

      // plataformas m√≥veis (eixo X)
      x += 8*step + 4;
      for (let i=0;i<5;i++) createMovingPlatform({x: x + i*step, y, z, w:3, d:3, axis:'x', amp:2.2, speed: 0.9 + i*0.15});
      createCheckpoint(x + 2*step, y, z);

      // trampolins para uma eleva√ß√£o
      x += 5*step + 4; y += 0.0;
      for (let i=0;i<4;i++) createBouncePad(x + i*step, y, z, 3, 3, 0x2196f3);
      // pouso mais alto
      createPlatform(x + 4*step, y+2.2, z, 4, 4, 0x81c784); y += 2.2;

      // plataformas que caem
      x += 4*step + 4;
      for (let i=0;i<6;i++) createFallingPlatform(x + i*step, y, z, 3, 3, 0xffd54f);
      createCheckpoint(x + 3*step, y, z);

      // viga girat√≥ria
      x += 6*step + 6;
      createPlatform(x, y, z, 4, 4, 0x66bb6a);
      createRotator(x, y+1.2, z, 10, 0.4, 1.6, 0xff7043);
      createPlatform(x + step, y, z, 4, 4, 0x66bb6a);

      // plataformas que somem/aparecem em ciclo
      x += step + 6;
      for (let i=0;i<6;i++) createDisappearPlatform(x + i*step, y, z, 3, 3, 2 + i*0.3, 0.5, 0x9e9e9e);

      // trecho final com lava e m√≥veis no eixo Z
      x += 6*step + 8;
      for (let i=0;i<5;i++) createLava(x + i*step, y-0.15, z, 3, 3, 0xe53935);
      x += 5*step + 4;
      for (let i=0;i<5;i++) createMovingPlatform({x: x, y, z: z + (i-2)*step*0.8, w:3, d:3, axis:'z', amp:2.4, speed: 1.2});

      // chegada
      x += 12;
      createCheckpoint(x, y, z);
      createPlatform(x, y, z, 6, 6, 0x4db6ac);
    })();

    // ======== L√≥gica ========
    function startGame(){
      gameStarted = true; overlay.style.display = 'none'; info.style.display = 'block';
      updateHUD();
    }

    function updateHUD(){
      info.innerHTML = `Checkpoint P1: ${p1.checkpointIdx} | P2: ${p2.checkpointIdx}`;
    }

    function respawnPlayer(p){
      p.mesh.position.copy(p.respawn);
      p.mesh.position.y = p.respawn.y; // garantir y correto
      p.vel.set(0,0,0);
      p.canJump = false;
    }

    // Controle/C√¢mara
    const moveSpeed = 0.12; // horizontal
    const jumpSpeed = 0.82;
    const gravity = 0.028;

    function handleInput(){
      // Player 1 ‚Äî WASD + Espa√ßo
      if (keys['w']) p1.mesh.position.z -= moveSpeed;
      if (keys['s']) p1.mesh.position.z += moveSpeed;
      if (keys['a']) p1.mesh.position.x -= moveSpeed;
      if (keys['d']) p1.mesh.position.x += moveSpeed;
      if (keys[' '] && p1.canJump){ p1.vel.y = jumpSpeed; p1.canJump = false; }

      // Player 2 ‚Äî Setas + Enter
      if (keys['arrowup']) p2.mesh.position.z -= moveSpeed;
      if (keys['arrowdown']) p2.mesh.position.z += moveSpeed;
      if (keys['arrowleft']) p2.mesh.position.x -= moveSpeed;
      if (keys['arrowright']) p2.mesh.position.x += moveSpeed;
      if (keys['enter'] && p2.canJump){ p2.vel.y = jumpSpeed; p2.canJump = false; }
    }

    function updatePhysics(p){
      p.vel.y -= gravity; // gravidade
      p.mesh.position.y += p.vel.y; // aplicar

      // queda do mapa
      if (p.mesh.position.y < -12){ respawnPlayer(p); }
    }

    // AABB helper para topo
    function topCollision(playerMesh, platMesh){
      const p = playerMesh.position, b = platMesh.position;
      const w = platMesh.geometry.parameters.width/2;
      const d = platMesh.geometry.parameters.depth/2;
      const topY = b.y + 0.25; // metade da altura (.5)
      const withinX = (p.x > b.x - w) && (p.x < b.x + w);
      const withinZ = (p.z > b.z - d) && (p.z < b.z + d);
      const fallingOnto = (p.y >= topY) && (p.y + playerSize*0.5 >= topY) && (p.y - p.vel.y <= topY + 0.05);
      return withinX && withinZ && fallingOnto;
    }

    function standOn(p, mesh){
      p.vel.y = 0; p.mesh.position.y = mesh.position.y + 0.26 + playerSize*0.5 - 0.51; // alinhar topo
      p.canJump = true;
    }

    // ======== Loop ========
    const tmpBoxP = new THREE.Box3();
    const tmpBoxO = new THREE.Box3();

    function animate(){
      requestAnimationFrame(animate);
      if (!gameStarted){ renderer.render(scene, camera); return; }

      // atualizar ciclos
      const t = performance.now()/1000;

      // plataformas m√≥veis
      for (const m of movingPlatforms){
        const prev = m.mesh.position.clone();
        if (m.axis === 'x') m.mesh.position.x = m.base.x + Math.sin(t * m.speed) * m.amp;
        else if (m.axis === 'z') m.mesh.position.z = m.base.z + Math.sin(t * m.speed) * m.amp;
        else if (m.axis === 'y') m.mesh.position.y = m.base.y + Math.sin(t * m.speed) * m.amp;
        m.mesh._delta = m.mesh.position.clone().sub(prev);
      }

      // plataformas que desaparecem (duty-cycle)
      for (const d of disappearPlatforms){
        const phase = ((t - d.t0) % d.period) / d.period; // 0..1
        const on = phase < d.duty;
        d.mesh.visible = on; // simples
      }

      // rotators
      for (const r of rotators){ r.rotation.y += 0.02 * r._rotSpeed; }

      // f√≠sica e colis√£o por jogador
      handleInput();
      for (const p of players){
        updatePhysics(p);

        // colidir com plataformas s√≥lidas (inclui algumas especiais vis√≠veis)
        const solids = [
          ...platforms,
          ...movingPlatforms.map(o=>o.mesh),
          ...fallingPlatforms.map(o=>o.mesh),
          ...disappearPlatforms.filter(o=>o.mesh.visible).map(o=>o.mesh)
        ];
        let stood = false;
        for (const s of solids){
          if (topCollision(p.mesh, s)){
            standOn(p, s); stood = true;
            // se for moving, empurrar junto um pouco
            if (s._delta) { p.mesh.position.add(s._delta); }
          }
        }
        if (!stood && p.vel.y <= 0) p.canJump = false;

        // bounce pads
        for (const b of bouncePads){ if (topCollision(p.mesh, b)) { p.vel.y = jumpSpeed * 1.45; showCenterMsg('Boing!'); } }

        // lava
        for (const l of lavaTiles){
          // AABB simples na horizontal + altura baixa
          const w=l.geometry.parameters.width/2, d=l.geometry.parameters.depth/2, bp=l.position;
          if (p.mesh.position.x>bp.x-w && p.mesh.position.x<bp.x+w &&
              p.mesh.position.z>bp.z-d && p.mesh.position.z<bp.z+d &&
              p.mesh.position.y <= bp.y + 0.6){
            respawnPlayer(p); showCenterMsg('üî• Lava!');
          }
        }

        // falling platforms l√≥gica
        for (const f of fallingPlatforms){
          if (topCollision(p.mesh, f.mesh) && f.state==='idle'){ f.state='armed'; f.timer = t + 0.45; }
          if (f.state==='armed' && t>f.timer){ f.state='falling'; }
          if (f.state==='falling'){ f.mesh.position.y -= 0.08; if (f.mesh.position.y < -20) f.state='gone'; }
        }

        // rotators colis√£o (Box3 vs Box3)
        tmpBoxP.setFromObject(p.mesh);
        for (const r of rotators){
          tmpBoxO.setFromObject(r);
          if (tmpBoxP.intersectsBox(tmpBoxO)){
            // bateu: empurra levemente e tira do ch√£o
            const dir = new THREE.Vector3().subVectors(p.mesh.position, r.position).setY(0).normalize();
            p.mesh.position.addScaledVector(dir, 0.35);
            p.vel.y = 0.5; p.canJump = false;
          }
        }

        // checkpoints (c√≠rculo de detec√ß√£o)
        for (let i=0;i<checkpoints.length;i++){
          const c = checkpoints[i];
          const dx=p.mesh.position.x - c.x, dz=p.mesh.position.z - c.z;
          if (dx*dx + dz*dz < 3.2*3.2){
            if (p.checkpointIdx !== i+1){
              p.checkpointIdx = i+1;
              p.respawn.set(c.x, c.y+1.1, c.z);
              updateHUD(); showCenterMsg('Checkpoint!');
            }
          }
        }
      }

      // c√¢mera: foca no meio dos dois jogadores
      const midX = (p1.mesh.position.x + p2.mesh.position.x)/2;
      const midY = (p1.mesh.position.y + p2.mesh.position.y)/2;
      const midZ = (p1.mesh.position.z + p2.mesh.position.z)/2;
      camera.position.set(midX, midY + 6.5, midZ + 12);
      camera.lookAt(midX, midY + 0.5, midZ);

      renderer.render(scene, camera);
    }
    animate();

    // ======== Resize ========
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>


