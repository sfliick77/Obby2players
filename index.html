<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Obby 3D - 2 Jogadores</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
        } 
        canvas { 
            display: block; 
        } 
        #overlay { 
            position: absolute; 
            top:0; 
            left:0; 
            width:100%; 
            height:100%; 
            background: rgba(0,0,0,0.8); 
            color: white; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            flex-direction: column; 
            font-size: 24px; 
            z-index: 10; 
        } 
        #info { 
            position: absolute; 
            top: 10px; 
            left: 10px; 
            color: #fff; 
            font-size: 18px; 
            text-shadow: 1px 1px 3px #000; 
            display: none; 
        } 
        /* Menu de op√ß√µes */ 
        #menu-btn { 
            position: absolute; 
            top: 15px; 
            right: 15px; 
            background: rgba(0,0,0,0.6); 
            color: white; 
            border: 1px solid #fff; 
            border-radius: 5px; 
            padding: 8px 15px; 
            cursor: pointer; 
            z-index: 20; 
            transition: background 0.3s; 
        } 
        #menu-btn:hover { 
            background: rgba(0,0,0,0.8); 
        } 
        #options-menu { 
            position: absolute; 
            top: 50px; 
            right: 15px; 
            background: rgba(0,0,0,0.8); 
            border: 1px solid #fff; 
            border-radius: 5px; 
            padding: 15px; 
            color: white; 
            z-index: 20; 
            display: none; 
            flex-direction: column; 
            gap: 10px; 
            min-width: 150px; 
        } 
        .menu-option { 
            display: flex; 
            align-items: center; 
            gap: 8px; 
            cursor: pointer; 
        } 
        .menu-option input[type="checkbox"] { 
            margin: 0; 
        }
        .player-info {
            position: absolute;
            top: 10px;
            padding: 5px 10px;
            background: rgba(0,0,0,0.6);
            border-radius: 5px;
            color: white;
        }
        #player1-info {
            left: 10px;
            border-left: 4px solid #ff5555;
        }
        #player2-info {
            left: 200px;
            border-left: 4px solid #5555ff;
        }
    </style>
</head>
<body>
    <div id="overlay">
        <h1>üèÉ Mini Obby 3D - 2 Jogadores</h1>
        <p>Pressione ENTER para come√ßar</p>
        <div style="text-align: left; margin-top: 20px;">
            <h3>Jogador 1 (Vermelho):</h3>
            <p>WASD para mover, Espa√ßo para pular</p>
            <h3>Jogador 2 (Azul):</h3>
            <p>Setas para mover, Enter (teclado num√©rico) para pular</p>
        </div>
    </div>
    
    <div id="player1-info" class="player-info">Jogador 1: 0/20</div>
    <div id="player2-info" class="player-info">Jogador 2: 0/20</div>
    
    <button id="menu-btn">‚ò∞ Menu</button>
    <div id="options-menu">
        <label class="menu-option">
            <input type="checkbox" id="lite-mode"> Modo Lite
        </label>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // --- Vari√°veis do jogo --- 
        let gameStarted = false;
        let gameOver = false;
        let liteMode = false;
        const overlay = document.getElementById('overlay');
        const player1Info = document.getElementById('player1-info');
        const player2Info = document.getElementById('player2-info');
        const menuBtn = document.getElementById('menu-btn');
        const optionsMenu = document.getElementById('options-menu');
        const liteModeToggle = document.getElementById('lite-mode');
        
        // Menu toggle
        menuBtn.addEventListener('click', () => {
            optionsMenu.style.display = optionsMenu.style.display === 'flex' ? 'none' : 'flex';
        });
        
        // Modo Lite
        liteModeToggle.addEventListener('change', () => {
            liteMode = liteModeToggle.checked;
            applyLiteMode();
        });
        
        function applyLiteMode() {
            if (liteMode) {
                player1Material.wireframe = true;
                player2Material.wireframe = true;
                platforms.forEach(platform => {
                    platform.material.wireframe = true;
                });
                scene.background = null;
                scene.background = new THREE.Color(0x222222);
            } else {
                player1Material.wireframe = false;
                player2Material.wireframe = false;
                platforms.forEach(platform => {
                    platform.material.wireframe = false;
                });
                // Restaurar textura de fundo
                loader.load(
                    'https://raw.githubusercontent.com/sfliick77/Background-c-u/main/277fba7bc86484d9f6cf37c87ee44de2.jpg',
                    function(texture){
                        scene.background = texture;
                    }
                );
            }
        }
        
        // Sistema de teclas melhorado
        const keys = {};
        window.addEventListener('keydown', e => {
            const key = e.key.toLowerCase();
            keys[key] = true;
            
            // Come√ßar jogo
            if(!gameStarted && !gameOver && (key === "enter" || key === " ")){
                startGame();
            }
            
            // Reiniciar
            if(gameOver && (key === "enter" || key === " ")){
                restartGame();
            }
        });
        
        window.addEventListener('keyup', e => {
            const key = e.key.toLowerCase();
            keys[key] = false;
        });
        
        // Prevenir comportamento padr√£o das teclas de dire√ß√£o e espa√ßo
        window.addEventListener('keydown', e => {
            if([' ', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright'].includes(e.key.toLowerCase())) {
                e.preventDefault();
            }
        });
        
        // --- Cena e c√¢mera --- 
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // --- Fundo --- 
        const loader = new THREE.TextureLoader();
        loader.load(
            'https://raw.githubusercontent.com/sfliick77/Background-c-u/main/277fba7bc86484d9f6cf37c87ee44de2.jpg',
            function(texture){
                scene.background = texture;
            }
        );
        
        // --- Luzes --- 
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(5,10,7);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));
        
        // --- Jogadores (2% maior) --- 
        // Jogador 1 (Vermelho)
        const player1Geometry = new THREE.BoxGeometry(1.02, 1.02, 1.02);
        const player1Material = new THREE.MeshStandardMaterial({color: 0xff5555});
        const player1 = new THREE.Mesh(player1Geometry, player1Material);
        player1.position.set(-2, 1, 0);
        scene.add(player1);
        
        // Jogador 2 (Azul)
        const player2Geometry = new THREE.BoxGeometry(1.02, 1.02, 1.02);
        const player2Material = new THREE.MeshStandardMaterial({color: 0x5555ff});
        const player2 = new THREE.Mesh(player2Geometry, player2Material);
        player2.position.set(2, 1, 0);
        scene.add(player2);
        
        // Propriedades dos jogadores
        const players = [
            {
                mesh: player1,
                velocity: { x: 0, y: 0, z: 0 },
                canJump: false,
                checkpoint: 0,
                finished: false,
                color: 0xff5555
            },
            {
                mesh: player2,
                velocity: { x: 0, y: 0, z: 0 },
                canJump: false,
                checkpoint: 0,
                finished: false,
                color: 0x5555ff
            }
        ];
        
        // --- Plataformas (2% maiores) --- 
        const platforms = [];
        const checkpoints = [];
        const platformColors = [0x00ff00, 0xffff00, 0xff00ff, 0x00ffff];
        
        function createPlatform(x, y, z, width = 3.06, depth = 3.06, color = 0x00ff00) {
            const geo = new THREE.BoxGeometry(width, 0.51, depth);
            const mat = new THREE.MeshStandardMaterial({color: color});
            const plat = new THREE.Mesh(geo, mat);
            plat.position.set(x, y, z);
            scene.add(plat);
            platforms.push(plat);
            return plat;
        }
        
        // Criar plataformas tipo Obby com cores variando (2% mais distantes)
        for(let i = 0; i < 20; i++) {
            const x = i % 5 * 6;
            const z = Math.floor(i / 5) * 6;
            const color = platformColors[i % platformColors.length];
            const platform = createPlatform(x, 0, z, 3.06, 3.06, color);
            
            // Marcar como checkpoint a cada 5 plataformas
            if (i % 5 === 0 && i > 0) {
                checkpoints.push(i);
            }
        }
        
        // Plataforma final (maior e diferente)
        const finalPlatform = createPlatform(24, 0, 24, 6.12, 6.12, 0xff0000);
        checkpoints.push(20); // √öltima plataforma como checkpoint
        
        // --- Inimigos (cilindros rotativos) --- 
        const enemies = [];
        function createEnemy(x, z, height = 2) {
            const geometry = new THREE.CylinderGeometry(0.5, 0.5, height, 16);
            const material = new THREE.MeshStandardMaterial({color: 0xff0000});
            const enemy = new THREE.Mesh(geometry, material);
            enemy.position.set(x, height/2, z);
            scene.add(enemy);
            enemies.push(enemy);
            return enemy;
        }
        
        // Adicionar alguns inimigos
        createEnemy(6, 2);
        createEnemy(12, 8);
        createEnemy(18, 14);
        createEnemy(6, 20);
        
        // --- Controles e f√≠sica --- 
        const gravity = 0.05;
        let currentCameraTarget = 0; // 0: vis√£o geral, 1: jogador 1, 2: jogador 2
        
        function startGame() {
            gameStarted = true;
            overlay.style.display = 'none';
            player1Info.style.display = 'block';
            player2Info.style.display = 'block';
        }
        
        function restartGame() {
            document.location.reload();
        }
        
        function updatePlayerInfo() {
            player1Info.textContent = `Jogador 1: ${players[0].checkpoint}/20`;
            player2Info.textContent = `Jogador 2: ${players[1].checkpoint}/20`;
            
            // Verificar se ambos terminaram
            if (players[0].finished && players[1].finished) {
                gameOver = true;
                overlay.style.display = 'flex';
                overlay.innerHTML = `
                    <h1>üéâ Fim de Jogo!</h1>
                    <p>Jogador 1: ${players[0].checkpoint}/20 plataformas</p>
                    <p>Jogador 2: ${players[1].checkpoint}/20 plataformas</p>
                    <p>Pressione ENTER ou ESPA√áO para reiniciar</p>
                `;
            }
        }
        
        // Inicializar informa√ß√µes dos jogadores
        updatePlayerInfo();
        
        // Fun√ß√£o de anima√ß√£o
        function animate() {
            requestAnimationFrame(animate);
            
            if(gameStarted && !gameOver) {
                // Rotacionar inimigos
                enemies.forEach(enemy => {
                    enemy.rotation.y += 0.02;
                });
                
                // Atualizar cada jogador
                players.forEach((player, index) => {
                    const mesh = player.mesh;
                    const velocity = player.velocity;
                    let canJump = player.canJump;
                    
                    // Movimento baseado no jogador
                    if (index === 0) { // Jogador 1 - WASD
                        if(keys['w'] || keys['arrowup']) velocity.z = -0.2;
                        if(keys['s'] || keys['arrowdown']) velocity.z = 0.2;
                        if(keys['a'] || keys['arrowleft']) velocity.x = -0.2;
                        if(keys['d'] || keys['arrowright']) velocity.x = 0.2;
                    } else { // Jogador 2 - Setas
                        if(keys['arrowup']) velocity.z = -0.2;
                        if(keys['arrowdown']) velocity.z = 0.2;
                        if(keys['arrowleft']) velocity.x = -0.2;
                        if(keys['arrowright']) velocity.x = 0.2;
                    }
                    
                    // Aplicar velocidade e desacelera√ß√£o
                    mesh.position.x += velocity.x;
                    mesh.position.z += velocity.z;
                    velocity.x *= 0.9;
                    velocity.z *= 0.9;
                    
                    // Gravidade
                    velocity.y -= gravity;
                    mesh.position.y += velocity.y;
                    
                    // Verificar colis√£o com o ch√£o e plataformas
                    if(mesh.position.y < 0.5) {
                        mesh.position.y = 0.5;
                        velocity.y = 0;
                        canJump = true;
                    }
                    
                    player.canJump = canJump;
                    
                    // Verificar colis√£o com plataformas
                    let onPlatform = false;
                    let currentCheckpoint = player.checkpoint;
                    
                    platforms.forEach((p, i) => {
                        const px = p.position.x, py = p.position.y, pz = p.position.z;
                        const platformHalfWidth = p.geometry.parameters.width / 2;
                        const platformHalfDepth = p.geometry.parameters.depth / 2;
                        
                        if(mesh.position.x > px-platformHalfWidth && mesh.position.x < px+platformHalfWidth &&
                           mesh.position.z > pz-platformHalfDepth && mesh.position.z < pz+platformHalfDepth &&
                           mesh.position.y > py && mesh.position.y < py + 0.5 + 0.5) {
                            mesh.position.y = py + 0.5;
                            velocity.y = 0;
                            player.canJump = true;
                            onPlatform = true;
                            
                            // Atualizar checkpoint se for uma plataforma √† frente
                            if (i > currentCheckpoint) {
                                player.checkpoint = i;
                                updatePlayerInfo();
                                
                                // Verificar se chegou ao final
                                if (i === platforms.length - 1) {
                                    player.finished = true;
                                    p.material.color.set(0x00ff00); // Mudar cor para verde
                                }
                            }
                        }
                    });
                    
                    // Se n√£o est√° em nenhuma plataforma, aplicar gravidade
                    if (!onPlatform && mesh.position.y > 0.5) {
                        player.canJump = false;
                    }
                    
                    // Verificar colis√£o com inimigos
                    enemies.forEach(enemy => {
                        const dx = mesh.position.x - enemy.position.x;
                        const dz = mesh.position.z - enemy.position.z;
                        const distance = Math.sqrt(dx*dx + dz*dz);
                        
                        if(distance < 1.2) { // Colis√£o com inimigo
                            // Resetar para o √∫ltimo checkpoint
                            const checkpointIndex = player.checkpoint;
                            const checkpointPlatform = platforms[checkpointIndex];
                            
                            mesh.position.set(
                                checkpointPlatform.position.x,
                                checkpointPlatform.position.y + 1,
                                checkpointPlatform.position.z
                            );
                            
                            velocity.x = 0;
                            velocity.y = 0;
                            velocity.z = 0;
                        }
                    });
                    
                    // Pular (controles diferentes para cada jogador)
                    if (index === 0 && (keys[' ']) && player.canJump) {
                        velocity.y = 0.8;
                        player.canJump = false;
                    }
                    
                    if (index === 1 && (keys['enter']) && player.canJump) {
                        velocity.y = 0.8;
                        player.canJump = false;
                    }
                });
                
                // Controle de c√¢mera - alternar com a tecla C
                if (keys['c']) {
                    currentCameraTarget = (currentCameraTarget + 1) % 3;
                    keys['c'] = false; // Para n√£o alternar v√°rias vezes seguidas
                }
                
                // Posicionar a c√¢mera baseado no alvo selecionado
                if (currentCameraTarget === 0) {
                    // Vis√£o geral dos dois jogadores
                    const midX = (player1.position.x + player2.position.x) / 2;
                    const midZ = (player1.position.z + player2.position.z) / 2;
                    const maxY = Math.max(player1.position.y, player2.position.y);
                    
                    camera.position.x = midX;
                    camera.position.z = midZ + 15;
                    camera.position.y = maxY + 8;
                    camera.lookAt(midX, maxY, midZ);
                } else {
                    // Focar em um jogador espec√≠fico
                    const targetPlayer = players[currentCameraTarget - 1];
                    camera.position.x = targetPlayer.mesh.position.x;
                    camera.position.z = targetPlayer.mesh.position.z + 10;
                    camera.position.y = targetPlayer.mesh.position.y + 5;
                    camera.lookAt(targetPlayer.mesh.position);
                }
            }
            
            renderer.render(scene, camera);
        }
        
        animate();
        
        // Ajustar tamanho ao redimensionar janela
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>